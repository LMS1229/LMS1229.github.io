---
title: Manacher 알고리즘
layout: post
author:
name: 이민석
date: 2023-12-05 23:00:00 +0900
categories: ["CS", "알고리즘"]
tag : ["문자열"]
math: true
---

## 개요
길이가 $N$인 어떤 문자열$S$의 부분 문자열 중, 회문인 문자열 구해야 한다면 어떻게 구할 것인가?\
가장 간단한 방법으로 $i \leftarrow 0 \sim N-1$ 까지 순회하면서 모든 $i$ 에 대하여 $S[i]$ , $(S[i],S[i+1])$ 를 중심으로 하여 양 옆으로 모두 탐색하며 회문을 찾는 방법이 있을 것이다. 이러한 알고리즘의 시간 복잡도는 $O(N^2)$ 이다.\
그러나 지금 소개할 Manacher 알고리즘을 이용한다면 문제를 해결하는데 $O(N)$ 의 시간 복잡도를 가지게 된다. 

## Manacher 알고리즘

### 회문의 특성 
먼저 길이가 $N$이고 회문인 문자열 $S$ 에 대해서 회문의 중심의 위치를 $i$ 라 하자. 
>짝수 길이의 회문은 마지막에 설명하겠다.
{: .prompt-info}

$k>i$ 일 때, $S$ 에 대해서 $S[k]$ 를 중심으로한 회문 문자열의 길이는 $S[2i-k]$ 를 중심으로 하는 회문 문자열의 길이가 된다.\
따라서 회문인 문자열 $S$ 대해서 회문의 중심의 위치를 $i$라 할 때, $S[k]$ 를 중심으로한 회문 문자열은 $S[2i-k]$ 를 중심으로 하는 회문 문자열과 같다. 


#### 증명
문자열 $S$ 에 대해서 $S[i+t]=S[i-t]$ 이다.
이 때, $k=i+x$ 라 한다면 $S[k+y]=S[i+x+y]=S[i-x-y]=S[2i-k-y]$ 이 된다.\
따라서 $S[2i-k]$ 를 중심으로 하는 회문 문자열의 길이가 $2r+1$ 일 때
$(S[2i-k-r], S[2i-k-r+1],...,S[2i-k],...,S[2i-k+r-1],S[2i-k+r]) = $ $ (S[k+r], S[k+r-1],...,S[k],...,S[k-r+1],S[k-r])$ 이 된다.\
$S[2i-k-y]=S[2i-k+y]$ 이므로 $S[k-r:k+r]$ 은 회문 문자열이 된다

### 부분 문자열
그렇다면 어떤 문자열 $S$ 의 부분 회문 문자열 $P$의 중심이 $i$ 이고 길이가 $2r+1$ 이라 하자.\
$k>i$ 에 대하여 $S[k]$ 중심으로 하면 어떻게 될까? 먼저, 필요한 값들에 대해 정의하겠다.
1. $2R[i] + 1=$문자열 $S$에 대하여 중심이 $S[i]$ 일 때, 가장 큰 회문인 문자열의 길이

그러면 다음 3가지 경우로 나누어 회문을 구할 수 있다. 

1. $k \gt i+r$
2. $k \le i+r$
    1. $k+R[2k-i] \lt i+r$
    2. $k+R[2k-i] \ge i+r$

#### $k \gt i+r$
해당 경우엔 $P$에서 간접적으로 회문을 구할 수 없기 때문에 직접 구해야 한다.

#### $k+R[2k-i] \lt i+r$
해당 경우엔 $R[k]=R[2k-i]$ 가 된다. 그 이유는 위의 회문의 성질을 파트에서의 증명과 같다. 

#### $k+R[2k-i] \ge i+r$
해당 경우에는 먼저 $k$ 를 기준으로 $i+r-k=t$ 라 한다면 $P[k-t:k+t]$ 는 회문 문자열이다. \
왜냐하면 회문의 성질에 의해 $k+R[2k-i] \ge i+r \rightarrow (2k-i)-R[2k-i] \le i-r$ 이기 때문에 $R[2k-i] \ge t$ 가 되기 때문에 $P[2k-i-t:2k-i+t]$ 는 회문 문자열이고 $P[2k-i-t:2k-i+t] = P[k-t:k+t]$ 이기 때문이다.

그러나, 우리는 $P[k+t+x]=P[k-t-x]$ 에 대한 정보가 없기 때문에 $x\leftarrow 1$ 부터 $P[k+t+x]=P[k-t-x]$ 를 검사해보면 $R[k]$ 를 구할 수 있게 된다. 

### 알고리즘
위에서 설명한 것을 정리하면 다음과 같다. 
1. $2R[i] + 1=$문자열 $S$에 대하여 중심이 $S[i]$ 일 때, 가장 큰 회문인 문자열의 길이라 하자.
2.  $k>i$ 에 대하여 $S[k]$ 중심으로 하는 회문 문자열의 길이는 다음과 같다. 
    1. $k \gt i+r$ 라면 $S[k]$ 중심으로 하는 회문 문자열을 직접 구한다. 
    2. $k \le i+r$ 이라면 
        1. $k+R[2k-i] \lt i+r$ 라면 $R[k]=R[2k-i]$ 이다. 
        2. $k+R[2k-i] \ge i+r$ 라면 $R[k] \ge i+r-k$ 이므로 $R[k]\leftarrow i+r-k$ 부터 시작하여 $R[k]$ 를 증가시키며 찾는다.

즉, $i+r$ 이 클수록 $R[k]$ 를 찾는데 소모되는 시간이 줄어드는 것을 알 수 있다.\
이는 $i \leftarrow 0 \sim N-1$ 까지 $R[i]$ 를 찾으며 $i+R[i]$ 가 최대가 되는 $i$ 와 $i+R[i]$ 를 저장하면 된다. 다음은 예시 코드이다.

```c++
#include <vector>
#include <iostream>
using namespace std;

vector<int> manacher(const string& s, int n) {
    vector<int> r(n);
    int max_r = 0;
    int max_i = 0;
    for (int i = 0; i < n; ++i) {
        if (max_r < i) {
            r[i] = 0;
        }
        else {
            r[i] = min(r[2 * max_i - i], max_r - i);
        }
        while (0 <= i - r[i] - 1 && i + r[i] + 1 < n && s[i - r[i] - 1] == s[i + r[i] + 1]) {
            ++r[i];
        }
        if (max_r < i + r[i]) {
            max_r = i + r[i];
            max_i = i;
        }
    }
    return r;
}

int main() {
    string s;
    cout << "input string:";
    cin >> s;
    vector<int> r = manacher(s, s.size());
    for (int i = 0; i < s.size(); ++i) {
        cout << "Center index = " << i << "\n" << "palindrome = " << s.substr(i - r[i], 2 * r[i] + 1) << "\n" << endl;
    }
    return 0;
}
```

그렇다면 짝수 길이의 회문은 어떻게 구할까?

#### 짝수 길이의 회문
이는 문자열에서 문자 사이마다 문자열에 존재하지 않는 문자를 삽입하면 된다. 다음은 예시이다.

$$
abba \rightarrow \#a\#b\#b\#a\#
$$

이렇게 변경한 뒤, 회문 문자열을 구하면 $\\#$ 문자를 중심으로 하는 회문 문자열에서 $\\#$ 을 제거한다면 짝수 길이의 회문 문자열이 된다. 


### 시간 복잡도
얼핏 보면 이중 반복문으로 $O(N^2)$으로 보일 수 있으나, while문의 총 수행 횟수는 총 $O(N)$ 이다. 그 이유는 다음과 같다.
1. while문을 수행하는 경우는 $k \gt i+r$ 이거나 $k+R[2k-i] \ge i+r$ 인 경우 뿐이다. 
2. 이 경우에 `max_r` 의 값은 $p[k]$ 가 증가한 값만큼 커지게 된다.
3. 즉, `max_r` 은 $N$ 보다 작으므로 모든 $i$ 에 대하여 $p[i]$ 가 증가한 값의 합은 $N$ 보다 작거나 같다. 
4. 따라서 while문의 수행 횟수는 $O(N)$ 이다. 