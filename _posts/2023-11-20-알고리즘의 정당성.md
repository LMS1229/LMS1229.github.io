---
title: 알고리즘의 정당성
author:
name: 이민석
date: 2023-11-20 23:08:00 +0900
categories: ["CS", "알고리즘"]
tag : ["알고리즘"]
math : true
---

## 알고리즘의 증명
우리가 알고리즘에서 가장 중요한 것 중, 하나는 단연코 `올바른 답을 내놓는가?` 이다.\
이를 확인하기 위해, 여러 입력에 대한 알고리즘의 출력와 올바른 출력을 비교할 것이다.\
하지만 이런 방법은 그다지 좋지 못하다. 근본적으로 이 방법은 `알고리즘이 타당한가?` 에 대한 질문제 `아니오` 는 확실하게 말할 수 있지만 `예` 라고는 대답할 수 없다.\
그렇기에 우리는 `알고리즘이 옳은가?` 에 대해서 수학적인 증명을 할 필요가 있다. 이제 그러한 증명을 위한 방법을 몇 가지 소개하겠다.


## 수학적 귀납법
도미노가 쓰러지는 상황을 생각해보자. 일렬로 세워진 도미노에서 첫 번째 도미노를 쓰러트리면 나머지 도미노도 자연스럽게 쓰레지게 된다. 하지만 무한히 세워진 도미노라면 중간에 결국 한 번은 멈추지 않을까? 누구나 직관적으로 안 멈춘다는 걸 알지만 설명을 위해 진행을 하겠다.\
먼저 우리는 2가지 성질을 알고 있다.

1. 첫 번째 도미노는 직접 쓰러트린다. 
2. 어떤 도미노가 쓰러지면 다음 도미노도 반드시 쓰러진다.

따라서 우리는 모든 자연수 $n$ 에 대하여 첫 번째 도미노를 쓰러트리면 남은 $n-1$ 개의 도미노가 쓰러짐을 증명하면 된다. 
1. $n=1$ 이면 1개의 도미노가 있는 것이므로 첫 번째 성질에 의해 성립한다.
2. $n=k$ 일 때 성립한다고 가정하자. 그렇다면 2번 성질에 의해 $k+1$ 번째 도미노도 쓰러지게 되므로 $n=k+1$ 일 때도 성립한다.
3. 따라서 모든 자연수 $n$ 에 대하여 성립한다.

이렇듯 초기 단계에서 성립함을 보이고 한 단계에서 성립하면 다음 단계 또한 성립함을 보이며 증명할 수 있습니다. 이러한 방법은 실제 알고리즘의 증명에서도 많이 사용된다. 그 이유로는 수많은 알고리즘이 반복적 요소를 가지고 있어, 귀납법을 통해 알고리즘의 반복적 요소가 실제 정답으로 가고 있음을 보일 수 있기 때문이다.

귀납법을 이용하여 정당성을 증명하기 위해선 `반복문 불변식` 이라는 개념을 사용한다.

### 반복문 불변식
반복문 불변식이란 반복문이 수행될 때 마다 중간 결과가 우리가 원하는 답으로 가기 위해 명시된 조건을 말한다. 즉, 우리가 원하는 답을 계산하기 위해 반복문의 조건이 변하지 않고 성립한다는 의미이다. 이를 확인할 때, 총 3가지를 판단해야 한다.

1. 초기 조건: 반복문이 시작되기 전에 불변식이 참이여야 한다.
2. 유지 조건: 반복문을 반복하기 전에 불변식이 참이여야 한다. 
3. 종료 조건: 반복문이 종료될 때, 해당 불변식이 알고리즘의 정당성을 증명할 유용한 성질이여야 한다. 

간단한 예시로 다음의 삽입 정렬 코드를 보자

```c++
void insertionsort(const vector<int>& A){
    //불변식 1. A[0:i-1] 은 비내림차순으로 정렬되어 있다.
    for(int i = 1; i < A.size(); ++i){
        int ele = A[i];
        int j = i - 1;
        //불변식 2. A[j+1:i] 의 모든 원소는 ele 보다 크거나 같다.
        while(j >= 0 && A[j] > ele){
            A[j + 1] = A[j];
            --j;
        }
        A[j + 1]=ele;
    }
}
```

`불변식 1`을 토대로 위 조건을 대입해보면 다음과 같다.
1. 초기 조건: 반복문이 시작 되기전 $i=1$ 에서 $A[0:0]$ 는 자명하게 정렬된 상태이다. 
2. 유지 조건: while문에 의해 $A[i]$ 보다 큰 $A[k],A[k+1], ... , A[i-1]$ 은 모두 $A[k+1],A[k+2], ... , A[i]$ 로 이동했고 $A[k]$ 자리에 기존 $A[k]$ 를 대체하므로 여전히 $A[0:i-1]$ 까지 정렬된 상태이다.
3. 종료 조건: $i=A.size()=n$ 일 때 종료되므로 $A[0:n-1]$은 정렬된 상태이다. 

따라서 위 알고리즘으로 정수로 이루어진 어떤 배열이든 정렬할 수 있음을 알 수 있다.

## 귀류법
현재 여러명의 승객을 태우고 운행중인 버스를 생각해보자. 초인적인 운전기사는 모든 승객이 어느 정류장에서 내리는지 알고 있다. 그런데 모든 승객을 태우고 종점까지 가기엔 기름이 부족하다는 것을 알고 지금 일부 승객을 내리게 하여 사용되는 기름을 줄이고 종점까지 어느 승객도 태우지 않기로 했다.\
당신이 운전기사라면 내리는 승객을 최소화하기 위해 누구를 내리게 할 것인가?

정답은 `제일 많은 정류장을 거치는 승객 순서로 내리기` 이다.

>위 방법보다 적은 승객을 내리게 하는 방법이 있다고 가정하자.
>그렇다면 현재 내린 승객들 중 1명 $x$를 다시 태우고 남았던 승객 중에 한 명 $y$를 내리게 했을 때, 사용되는 기름의 양이 적은 경우가 존재함을 의미한다. 그러나 $x$가 거쳐간 정류소의 수가
$y$보다 많아, 무조건 기름을 더 쓰므로 이는 모순이다. 
>따라서 `제일 많은 정류장을 거치는 승객 순서` 로 내리는 방법이 가장 적은 승객을 내리게 하는 방법이다.

우리는 결론이였던 `제일 많은 정류장을 거치는 승객 순서로 내리기` 를 부정했을 때, 원하는 결과인 `최소 승객으로 내리게 하기`를 못함을 증명했다.

이렇듯 우리가 원하는 결론을 부정했을 때, 이는 논리적으로 모순임을 증명하는 방법은 귀류법이라 한다. 
