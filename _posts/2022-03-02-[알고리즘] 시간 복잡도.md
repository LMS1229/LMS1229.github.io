---
title: "[알고리즘] 시간 복잡도"
author:
name: 이민석
date: 2022-03-02 23:55:00 +0900
categories: ["CS"]
tag: ["알고리즘"]
math: true
---

# 누가 더 효율적일까?

A와 B가 서로 같은 문제를 해결하기 위해 알고리즘을 구현해냈다. 이 둘의 알고리즘을 어떻게 비교할 수 있을까?

## 데이터 넣어보기

가장 쉬운 방법 중 하나로, 데이터를 직접 입력해보며 연산하는데 총 걸리는 시간을 비교해보자. 

아래는 비교한 결과이다.

>| 입력 데이터 개수| A 알고리즘| B 알고리즘|
>|:----------|:---------|:--------|
>| 100       | 1s       | 2s      |

## 알고리즘 비교

 우리는 위의 결과를 보면 A 알고리즘이 더 우수하다고 생각된다. 왜냐면 A가 B보다 수행시간이 적기 때문이다. 
그럼 이번엔 데이터를 10배 늘리겠다.

>| 입력 데이터 개수| A 알고리즘| B 알고리즘|
>|:----------|:---------|:--------|
>| 100       | 1s       | 2s      |
>| 1000      | 10s      | 6s      |

- A의 알고리즘은 데이터가 10배 늘어남에 따라 시간도 10배가 증가했고 B의 알고리즘은 3배 증가했다. 
- 그럼 데이터의 크기가 커질수록 A와 B의 수행시간 차이는 더욱 벌어진다.
- 따라서 우린 B의 알고리즘이 좀 더 효율적이라고 볼 수 있다.

이처럼 우리는 알고리즘을 평가할 때 `입력 데이터의 크기에 따라 수행시간이 어떻게 변하는가` 로 평가한다.

---
그럼 매번 알고리즘을 구현할 때마다 이런 과정으로 검증해야할까요??
- 테스트할 데이터가 없으면? 
- 데이터가 있는데 그 데이터만으론 유의미한 차이가 없다면?

이런 상황에서 알고리즘을 비교하기 위해, 우리는 입력 데이터와 수행시간(연산 횟수)의 연관 관계를 나타내는 `시간 복잡도`를 이용하면 된다.

---

# 연산 횟수
연산 횟수는 어떻게 구할까?

다음과 같은 코드를 보자

```C++
//case 1
int count=0;
for(int i=1;i<=n;++i)
{
   count++;
}
```

먼저 `count++` 의 연산 횟수는 `1`이라 보자. 

```C++
//case 1
int count=0;
for(int i=1;i<=n;++i)
{
   count++;       //1
}
```

그렇다면 `count++` 를 총 몇 번 수행할까? 반복문에서 수행하니 반복문을 몇 번 수행하는지 확인하면 된다. 반복문을 보면 `i`를 `1`부터 시작해서 `n`보다 커질때 까지 `i` 에 `1`을 더한다. 따라서 반복문은 총 `n`번 수행하게 된다.

```C++
//case 1
int count=0;
for(int i=1;i<=n;++i)   //n
{
   count++;       //1
}
```

따라서 연산 횟수가 `1`인 연산을 총 `n`번 반복하니 `n`번의 연산을 했다고 볼 수 있다.

이 반복문을 `n`번 반복한다면 `n²` 번 연산했다고 볼 수 있다.
```C++
//case 2
int count=0;
for(int i=1;i<=n;++i)       //n
{
    for(int j=1;j<=n;++j)   //n
    {
        count++;      //1
    }
}
```

따라서 `case 1` 의 연산 횟수는 `n` 이 커짐에 따라 정비례하지만 `case 2`의 알고리즘은 제곱비례가 된다. 

# 시간 복잡도

위처럼 입력크기에 따라 연산횟수가 고정된 알고리즘이 있다면 입력크기가 같아도 데이터의 형태가 다르면 연산횟수가 달라지는 알고리즘도 존재한다. ex)`거품 정렬`

또한, 모든 단계를 거치며 완벽한 연산 횟수를 구하는 것은 매우 어렵다.
따라서 우린 대략적인 예측을 위해 점근 표기법을 이용하여 크게 3가지 경우로 나누어 시간 복잡도를 표기한다.

각 경우를 알아보기 전에 입력크기 `n` 에 대하여 함수 $$ f(n) $$ 을 알고리즘의 연산 횟수라 하자

---
1. 최선의 경우
 - 최선의 경우는 알고리즘이 가장 빠르게 수행되는 경우를 의미한다. 
 - 즉, 알고리즘이 아무리 빨라도 이보다 빠를 수는 없음을 의미한다. 
 - 따라서 점근적 하한을 이용하여 표기한다.
 
>음이 아닌 정수 $$ k $$ 와 양의 실수 $$ c $$에 대하여
>
>$$ k \le n, 0\le c*g(n) \le f(n) $$
>
>를 만족하는 $$ g(n) $$ 에 대하여 다음과 같이 표기한다.
>
>$$ f(n) \in \Omega(g(n)) $$


2.최악의 경우
  - 최악의 경우엔 알고리즘이 가장 느리게 수행하는 경우를 의미한다. 
  - 즉, 알고리즘이 아무리 느려도 이것보단 느리게 동작할 수 없음을 의미한다.
  - 따라서 점근적 상한을 이용하여 표기한다.

>음이 아닌 정수 k 와 양의 실수 c에 대하여
>
>$$k \le n, c*g(n) \ge f(n) $$ 
>
>를 만족하는 $$ g(n) $$ 에 대하여 다음과 같이 표기한다.
>
>$$ f(n) \in O(g(n)) $$

3.평균의 경우
  - 최악의 경우와 최선의 경우 중간을 의미한다.
  - 따라서 최악, 최선의 경우의 집합의 교집합을 의미한다.

>모든 음이 아닌 정수 k 와 양의 실수 c,d에 대하여
>
>$$k \le n, c*g(n) \le f(n)\le d* g(n) $$ 
>
>를 만족하는 $$ g(n) $$ 에 대하여 다음과 같이 표기한다.
>
>$$ f(n) \in \Theta (g(n)), \Theta (g(n))= \Omega(g(n)) \cap O(g(n)) $$ 

---

- 그러나, 우린 보통 최악의 경우를 고려한다. 
- 왜냐하면 아무리 오래걸려도 이것보단 느릴 수 없다는 의미니, 어떤 상황에서도 대처할 수 있다. 
- 그렇기에 알고리즘의 시간복잡도는 보통 최악의 경우에 대해서 표기하고 이를 _Big-O_ 표기법이라 한다. 이 때 최악의 경우의 알고리즘 수행시간을 $$ T(n) $$ 이라 하자. 
- 만약 다항식의 형태로 표현된다면 최고차항을 제외한 모든 항과 최고차항의 계수를 제외한 것이 $$ g(n) $$ 이 된다. 
- 다음의 예시를 보면 된다.

$$ T(n)=2n^2+10n+4= O(n^2) $$

## 시간 복잡도의 종류
 이 블로그에서 가장 많이 보일 시간 복잡도는 다음과 같다. ( $n$ 은 데이터의 크기)
>1. $O(1)$ = 상수 시간
>2. $O(log\  n)$ = 로그 시간
>3. $O(n)$ = 선형 시간
>4. $O(n log\  n)$ = 선형 로그 시간
>5. $O(n^k)$ = 다항 시간
>6. $O(2^n)$ = 지수 시간
>7. $O(n!)$ = 팩토리얼 시간

 - 아래로 갈수록 알고리즘이 복잡해지며 수행시간이 늘어난다. 
 - 특히, 지수시간부턴 $n$ 이 조금만 늘어나도 수행시간이 기하급수적으로 늘어나게 된다.

 몇가지 경우를 설명하겠다.
 

## $O(1)$

- $n$ 의 크기와 상관없이 항상 일정한 시간이 걸리는 알고리즘의 시간복잡도다. 
- 하나의 예시로 배열의 임의의 원소를 출력하는 것이다.

```C++
int arr[1000]={...},n;
cin>>n;           //n은 항상 1000보다 작고 0보다 크다고 가정한다.
cout<<arr[n];
```
## $O(log\  n)$

- $n$ 에 대하여 실행시간이 _log n_ 에 비례하는 알고리즘의 시간복잡도다. 

- 대표적인 예로 이진탐색이 있다. 이진 탐색은 추후에 설명할 것이다.

```C++
bool find( int* arr, int begin, int end, int value)
{
   //정렬된 배열 arr에서 [begin,end] 범위내에 value가 존재하는 지를 반환하는 함수 
   if(begin>end)return false;
   int mid=(begin+end)/2;
   if(arr[mid]==value)
      return true;
   else if(arr[mid]>value)
      return find(arr,begin,mid-1,value);
   else //if(arr[mid]<value)
      return find(arr,mid+1,end,value);
}
```

## $O(n)$ 
 - $n$ 에 대하여 실행시간이 정비례하는 증가하는 알고리즘의 시간복잡도다. 
 - 대표적인 예로 n!을 구하는 알고리즘이 있다.

 ```C++
int factorial(int n)
{
   int ans=1;
   for(int i=2;i<=n;++i)
   {
      ans=ans*i;
   }
   return ans;
}
```

## $O(n^k)$ 
- $n$ 에 대하여 실행시간이 $n^k$에 비례하는 알고리즘의 시간복잡도다
- 대표적인 예는 삽입 정렬, 두 n차 정방행렬의 곱셈 알고리즘이 있다.
- 개인적인 생각으로 이때부터 데이터가 커질수록 시간이 증가하는게 체감이 된다.

## $O(2^n)$ 
- $n$ 이 1 증가하면 실행시간이 배로 증가하는 알고리즘의 시간복잡도다. 
- 여기서부턴 $n$ 이 조금만 커져도 실행시간이 기하급수적으로 증가한다. $n$ 이 `20` 증가하면 수행시간은 약 `1000000` 배 증가하게 된다. 
- 대표적인 알고리즘으로 집합 S에 대하여 S의 모든 부분 집합을 구하는 알고리즘이 있다.
