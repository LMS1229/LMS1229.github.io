---
title: 알고리즘 기초 이론
author:
name: 이민석
date: 2023-11-20 23:08:00 +0900
categories: ["CS", "알고리즘"]
tag : ["알고리즘"]
math : true
---

## 알고리즘이란?
어떤 입력에 의해서 특정한 출력이 발생하는 잘 정의된 일련의 계산 과정을 말한다. 
이 때의 입력은 어떠한 값이나 값들의 집합이 될 수 있고 출력 또한 어떠한 값이나 값들의 집합으로 볼 수 있다.

또는 어떤 계산 문제를 풀기 위한 일련의 과정이라고도 볼 수 있다.

간단한 예시로 5개의 카드에 각각 적힌 한 개의 숫자 중에서 가장 큰 숫자가 뭔지를 찾으려 한다면

>입력: 카드에 적힌 5개의 숫자
>출력: 5개의 숫자 중, 가장 큰 숫자

가 된다.

이러한 알고리즘은 주어진 계산 문제의 모든 입력에 대하여 올바른 정답을 출력한다면 `타당하다.` 라고 하며 그 알고리즘을 이용해, 해당 계산 문제를 `푼다.` 라고 이야기한다. 

또한 이를 표현하는 방법은 의사 코드와 같이 자연어, 컴퓨터 명령어, 순서도 등등 다양하게 존재한다.

## 알고리즘의 조건
그렇다면 알고리즘은 어떻게 만들어야 할까? 다음은 알고리즘이 가져야할 조건이다.
1. 입력
2. 출력
3. 유한성
4. 명확성
5. 수행 가능성

### 입력
알고리즘이 동작하기 위해선 0개 이상의 입력이 필요하다.
즉 입력이 없는 알고리즘이 존재할 수 있다. 예시로는 원주율의 2번째 자리수를 찾는 알고리즘을 들 수 있다.

### 출력
알고리즘이 동작하면 1개 이상의 출력이 발생한다.
만약 출력이 없다면 아래의 유한성을 판별할 수가 없다.

### 유한성
알고리즘은 유한 시간내로 반드시 종료된다.

만약 수열 ${a_n} = {1 \over 2^n}$ 의 등비 급수를 구하기 위하여 모든 항 $a_n$ 을 더한다면 유한 시간내로 종료되지 않으므로 알고리즘이라 볼 수 없다.

### 명확성
알고리즘의 각 단계는 모호하지 않아야 한다.
에를 들어 `너무 매운 음식을 제외한다.` 와 같은 모호한 과정이 아닌 `스코빌 지수가 4000SHU 이상인 음식은 제외한다.` 와 같이 명확해야 한다.

### 수행 가능성
알고리즘의 과정은 인간이 수행 가능 해야 한다. 
예를 들어 `5차 방정식으로 변형하여 대수적 해를 구한다.` 라는 과정은 불가능하므로 이런 과정은 알고리즘에 포함될 수 없다.

## 알고리즘 평가
이러한 조건들을 만족하여 우리는 주어진 문제를 풀 수 있는 알고리즘을 만들었다!\
그렇다면 그 문제를 풀 수 있는 알고리즘은 한 가지 뿐일까?

 답은 `아니오` 이다. 예를 들어 피보나치 수열의 $n$ 번째 수를 구하기 위한 알고리즘만 해도 재귀 함수를 이용한 알고리즘, 동적 계획법을 이용한 알고리즘, 거듭 제곱을 이용한 알고리즘이 존재한다.\
 그렇기에 우리는 '어떤 알고리즘을 사용해야 할까?' 라는 고민에 빠지게 된다. 즉, 현재 어떤 알고리즘을 사용하는 것이 더욱 `좋은지(=효율적인지)` 알아야 한다.\
 이를 위해 각 알고리즘의 `최악의 경우` 에서 `계산 시간`과 `사용하는 메모리의 크기`를 비교하며 이를 `점근적 표기법`을 통해 표현한다. 그리고 각각 `시간 복잡도` 와 `공간 복잡도` 라고 말한다. 

### 최악의 경우
먼저 여기서 말하는 `최악의 경우`는 계산 시간이 가장 큰 경우, 사용된 메모리가 가장 크게 되는 경우를 말한다. 왜 최악의 경우를 상정해야 할까? 그 이유는 다음과 같다.[^1]

>1. 해당 알고리즘이 해당 상황보다 나쁜 상황이 나오지 않기를 바라지 않아도 된다. 
>2. 최악의 경우가 상당히 빈번하게 등장할 수 있다.
>3. 최악의 경우가 아니더라고 최악의 경우에 거의 근접하는 수준인 상황일 때도 존재한다.

### 계산 시간
이는 단순하게 알고리즘을 이용하는데 수행되는 명령어의 개수라 보면 된다. 예시로 다음과 같은 알고리즘을 순차적으로 수행한다고 하자.
>1. i ← 1
>2. answer ← 0
>3. i 가 수열의 길이보다 크면 8로 이동하고 아니면 4로 이동한다.
>4. i번째 수가 answer보다 크면 5로 이동하고 아니면 6으로 이동한다.
>5. answer ← i 번째 수
>6. i ← i + 1
>7. 3으로 이동
>8. answer 출력

입력으로 주어진 수열의 길이가 $n$ 이라 한다면 각 과정을 수행하는데 1개의 명령어가 사용된다. 
이 때 1,2,8번은 1번씩, 4,6,7번은 $n$번, 5번은 최대 $n$ 번, 3번 연산은 $n+1$ 번 수행하므로
총 계산 시간은 최악의 경우, $5n+4$ 가 된다. 하지만 각 명령어별로 필요한 비용은 상황에 따라 다르므로 $an+b$ 로 표현하기도 한다. 

### 메모리 크기
위와 같이 알고리즘을 이용하는데 필요한 메모리의 크기이다. 위의 예시에선 입력에 필요한 $n$개의 수로 이루어진 수열을 저장, 알고리즘이 동작하는데 필요한 2개의 수$(i,answer)$가 필요하므로 $n+2$ 의 공간이 필요하다. 이 역시 상황에 따라 필요한 메모리 크기는 달라질 수 있다. (`int` 와 `long int`) 따라서 $an+b$ 로 표현하기도 한다. 

### 효율성 비교
똑같은 문제를 해결하는 다른 두 알고리즘 $A$, $B$ 에 대하여 수행 시간과 메모리 크기를 비교한다면 직접 비교하기엔 너무 어렵다. 왜냐하면 입력 크기에 따라 $A$ 가 더 빠를 수 있고 $B$ 가 더 빠를 수 있다. 이는 메모리 크기에도 똑같이 적용된다. \
각각의 수행시간이 $10n\log_{2}n$ , $n^2$ 이라 하자. $n=10$ 이라면 $10n\log_{2}n = 100\log_{2}{10} \gt 100 = n^2$ 이므로 $B$ 가 더 빠르다 볼 수 있다. 하지만 $n=1000$ 이라면 $10n\log_{2}n = 10000\log_{2}{1000} \lt 1000000 = n^2$ 로 $B$ 가 더 느리다.\
이러한 복잡한 상황을 해결하기 위해선 이를 단순화할 필요가 있다. 이러한 방법으로 증가차수를 이용하면 된다.\
이는 최고차항에 대해서 계수를 무시하고 비교하는 방법으로 이러한 방법을 사용해도 되는 이유는
최고차항이 아니라면 입력의 크기에 따라 증가하는 비율이 덜 중요해지기 때문이다. \
이를 이용해서 비교한다면 남은 최고차항의 차수가 더 작은 쪽을 우리는 효율적이라고 본다. 

## 점근적 효율성과 표기법
이제 우리는 알고리즘을 비교할 때 알고리즘의 구체적인 수행 시간보단 입력에 따라 변하는 수행시간의 변화율이 중요하다는 것을 알게 됐다.\
우리는 이러한 변화율을 `점근적 효율성`이라 부르며 이를 표기하는 방법으로 `점근적 표기법` 있다.\
점근적 표기법은 대표적으로 3가지가 있으며 이는 다음과 같이 정의된다.


$$f(x),g(x) \ge 0 ,\ ,\  (x \ge x_0 \ge 0)$$

$$f(n) \in O(g(n)) \Rightarrow f(n) \le cg(n) , (\forall n, n \ge n_0 \ge 0, c \ge 0)$$

$$f(n) \in \theta (g(n)) \Rightarrow c_1g(n) \le f(n) \le c_2g(n) , (\forall n, n \ge n_0 \ge 0, c_1,\ c_2 \ge 0)$$

$$f(n) \in \Omega (g(n)) \Rightarrow cg(n) \le f(n) , (\forall n, n \ge n_0 \ge 0, c \ge 0)$$

위에서부터 차례대로 `빅-오 표기법` , `쎄타 표기법`, `오메가 표기법` 이라 부르며 `점근적 상한`, `점근적으로 정확한 한계`, `점근적 하한` 이라고 부른다. 

### 점근적 상한
점근적 상한을 쉽게 풀이하면 수행 시간 $T(n) \in O(g(n))$ 이면 $T$ 는 $g$ 보다 빠르게 증가하지 않음을 의미한다. (상수계수는 무시)

### 점근적 하한
점근적 하한을 쉽게 풀이하면 수행 시간 $T(n) \in \Omega(g(n))$ 이면 $T$ 는 $g$ 보다 느리게 증가하지 않음을 의미한다. (상수계수는 무시)

### 점근적으로 정확한 한계
점근적으로 정확한 한계를 쉽게 풀이하면 수행 시간 $T(n) \in \theta(g(n))$ 이면 $T$ 는 $g$ 와 같은 정도로 증가함음을 의미한다. (상수계수는 무시)


[^1]: homas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein, Introduction to Algorithms, Second Edition, 문병로, 심규석, 이홍세 옮김, 한빛미디어, 2005, 26-27쪽