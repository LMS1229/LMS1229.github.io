---
title: "[자료구조] 배열"
author:
name: 이민석
date: 2022-03-04 15:00:00 +0900
categories: ["CS","자료구조"]
tag: ["자료구조"]
math: true
---

# 배열?

배열(array)은 원소들(값이나 변수)의 모음으로 구성된 자료구조로 각각의 원소들은 하나 이상의 첨자(인덱스)나 키를 이용하여 구분한다.

- 가장 간단한 형태론 1차원 배열이라 부르는 선형배열이다.

# 배열의 구조
 흔하게 볼 수 있고 이해하기 쉬운 1차원 배열로 설명하겠다. 길이가 n인 배열을 인덱스를 이용하여 표현하면 다음과 같다.

 ![Desktop View](/assets/img/[자료구조]배열/배열그림.png)

- 그림에서 보듯이 각각의 원소들은 `Index`로 구분할 수 있다. 
- 또한 배열의 원소들은 순차적으로 배치되어있다.
- 실제 컴퓨터의 메모리상에서도 연속적인 주소공간에 저장된다. 따라서 배열형태의 구조로 저장되어 있는 원소들을 Index를 이용해 순차적으로 접근할 수 있다. 그리고  첫 원소인 $a_0 $의 주소를 안다면 배열에 있는 다른 임의의 원소에 대해서 바로 접근할 수 있는 특징을 가지고 있다.

# 배열의 연산
## 접근
   - 임의의 배열에 `index` 가 n인 원소를 찾는다고 하자.
   ![Desktop View](/assets/img/[자료구조]배열/배열접근.png)

   - 배열의 구조에서 말했듯이 $a_0 $의 위치를 안다면 그 위치에서 n칸 떨어진 위치에 접근하면 된다. 
   - 이는 `(배열의 시작 주소+n*(원소의 크기))` 로 구할 수 있다.
   - 위 연산은 n의 크기와 상관없이 항상 일정하다. 따라서 $O(1)$ 의 시간 복잡도를 가진다.
## 특정 원소 검색
   `정렬되어 있지 않은 배열`에 대해서 특정 원소 $b$를 찾는다고 하자. 우린 `index`를 알지 못하므로 배열의 첫 원소부터 순차적으로 확인해야한다.
>1. i=0로 설정한다.
>2. 배열의 i번째 원소가 b와 같은지 확인한다.
>3. 같다면 종료한다.
>4. i를 1증가 시킨다.
>5. i가 배열의 길이보다 작다면 2로 돌아간다.

아래의 그림은 위 과정의 예시이다.   

   >$a_0,a_1,a_2,a_3,a_4$는 모두 다른 값이며 $b=a_4$ 이다.
   >![Desktop View](/assets/img/[자료구조]배열/배열검색.png)

   - 최악의 경우, 모든 원소를 순차적으로 확인해도 찾지 못한 경우이다.
   - n이 커짐에 따라 최악의 경우, 확인할 원소의 개수도 정비례 하므로 $O(n)$ 의 시간복잡도를 가진다.
   
>만약 `정렬된` 배열이라면 $ O(\log $ $n)$ 의 시간 복잡도로 해결 할 수 있다..
{: .prompt-tip }

## 원소 삽입
   배열의 `k`번째 `index` 에 새로운 원소 `b`를 추가한다고 하면 다음과 같은 과정을 거친다.

   >1. 먼저 `k` 번째 `index` 의 위치를 찾는다.
   ![Desktop View](/assets/img/[자료구조]배열/배열삽입위치.png)
   >2. `k` 번째 원소부터 마지막 원소까지 모두 한 칸씩 뒤로 밀어준다.
   ![Desktop View](/assets/img/[자료구조]배열/배열삽입중간.png)
   >3. `k` 번째 위치에 `b`를 넣는다.
   ![Desktop View](/assets/img/[자료구조]배열/배열삽입후.png)

각 과정의 시간복잡도는 다음과 같다
1. 임의의 위치에 있는 원소에 접근하므로 $ O(1) $
2. 최악의 경우엔 0번째 원소부터 마지막 원소까지 모두 n개의 원소가 이동하므로 $ O(n) $
3. 원소를 대입만 하기에 $ O(1) $ 

따라서 총 시간 복잡도는 $ O(n) $ 이다.
>배열의 끝 뒤에 원소를 추가한다면 2 의 과정을 상수 시간에 해결할 수 있다. 이 경우엔 $ O(1) $ 의 시간 복잡도를 가진다.
{: .prompt-tip }

## 원소 삭제
  배열의 `k`번째 `index` 의 원소 를 삭제한다고 하면 다음과 같은 과정을 거친다.

   >1. 먼저 `k` 번째 `index` 의 위치를 찾는다.
   ![Desktop View](/assets/img/[자료구조]배열/배열삽입위치.png)
   >2. `k` 번째 원소를 지운다.
   ![Desktop View](/assets/img/[자료구조]배열/배열삭제중간.png)
   >3. `k` 번째 부터 마지막까지의 원소를 한 칸씩 앞으로 당긴다.
   ![Desktop View](/assets/img/[자료구조]배열/배열삭제후.png)

   각 과정의 시간복잡도는 다음과 같다
1. 임의의 위치에 있는 원소에 접근하므로 $ O(1) $
2. 원소를 지우는 연산이므로 $ O(1) $
3. 최악의 경우, 1번째 원소부터 마지막 원소까지 n-1개의 원소가 1번씩 움직이므로 $ O(n) $

따라서 총 시간 복잡도는 $ O(n) $ 이다.

>배열의 마지막 원소를 삭제한다면 3 의 과정을 상수 시간에 해결할 수 있다. 이 경우엔 $ O(1) $ 의 시간 복잡도를 가진다.
{: .prompt-tip }
# 개인적인 생각
## 배열의 인덱스는 왜 0부터 시작할까?
 C언어에서 배열의 이름은 배열의 첫 원소가 위치한 메모리 주소를 가지고 있다. 그렇다면 인덱스는 왜 1이 아닌 0부터 시작할까? 내 개인적인 생각으로 이유는 총 2가지이다.
 1. 연산의 간단함을 위해
 2. 메모리 공간을 낭비하지 않기 위해
### 연산
 임의의 인덱스에 접근한다고 생각해보자. 배열의 인덱스가 1부터 시작한다면 `k`번째 인덱스의 주소를 알기 위해선 `배열의 첫 원소의 주소+(k-1)*(원소의 크기)` 와 같은 방식으로 찾아야 한다.하지만 인덱스가 0부터 시작한다면 `배열의 첫 원소의 주소+k*(원소의 크기)`로 k에서 1을 빼야하는 연산이 빠지게 된다. 전자와 후자의 연산을 비교하면 자명하게 후자의 연산량이 더 적다.
### 메모리 공간
 위의 문제를 해결하기 위해 `배열의 첫 원소의 주소+k*(원소의 크기)` 형태의 연산은 그대로 쓰고 인덱스 `k`를 구간 `[1,n]` 에 존재하는 임의의 정수라 하자. (`n` 은 배열의 길이)
 그렇다면 배열의 첫 원소의 주소에는 원소의 크기만큼의 공간은 사용하지 않게 된다. 이런 낭비를 하지 않기 위해 시작을 0으로 하여 인덱스의 범위를 `[0,n)` 로 한거라 생각한다.