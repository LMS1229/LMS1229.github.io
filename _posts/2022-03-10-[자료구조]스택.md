---
title: "[자료구조] 스택"
author:
name: 이민석
date: 2022-03-11 15:00:00 +0900
categories: ["CS","자료구조"]
tag: ["자료구조"]
math: true
---

# 스택...?
우리가 마트에서 물건을 살때 한 번 쯤은 재고입자나 제조일자를 확인한 적이 있을 것이다. 왜냐면 `가장 최근`에 만들거나 들어온게 신선할테니 말이다. 문서나 그림 작업을 하다보면 수정을 위해 실행취소를 한 적이 있을 것이다. 이러한 실행 취소는 `가장 최근` 에 했던 작업 순서대로 수행한 작업을 취소한다. 이는 `가장 최근`에 만들거나 작업한 내용을 `가져오는` 행동을 한다. 이처럼 `가장 최근(Last)`에 `넣은(In)` 데이터를 `제일 먼저(First) 빼는(Out)` 형태의 자료구조를 `스택` 이라 부른다. (LIFO 구조라 부르기도 한다.)

# 스택의 구조
 먼저 `스택`은 `가장 최근`에 넣은 데이터만 이용하므로 2가지의 데이터만 있으면 된다. 
 
```
1. 데이터를 저장할 배열
2. 마지막에 저장한 데이터의 위치 (top) 
```

```C++
class Stack{
    private:
        int top;
        int arr[MAXSIZE];
    public:
        //Operate Method....
}
```

# 스택의 연산
 `스택`에는 총 4가지 연산이 존재한다.
 1. 스택에 데이터를 넣는 push
 2. 스택의 제일 위에 있는 데이터를 조회할 수 있는 peek
 3. 스택의 제일 위에 있는 데이터를 제거하는 pop
 4. 스택이 비어있는 지 확인하는 isEmpty

 각각의 연산이 어떻게 이루어지는지는 그림과 함께 보자

## Push
먼저 `초기 스택`이 다음과 같다고 하자.

![초기스택](/assets/img/[자료구조]스택/초기스택.png)
_top이 왜 -1 인지는 isEmpty연산을 설명할때 알 수 있다._

이 `스택`에 숫자 `5` 를 넣어보자. 
- 그러면 `현재 스택`의 꼭대기에 들어가야한다. 
- 따라서 저장한 데이터의 위치 `top`보다 `1` 만큼 큰 `0`에 넣으면 된다. 

```C++
arr[top+1]=5;
```

![스택 Push 첫 단계](/assets/img/[자료구조]스택/스택삽입1.png)

그리고 마지막에 넣은 데이터는 `top` 보다 `1` 크기 때문에 `top` 을 1 증가시킨다. 

![스택 Push 종료](/assets/img/[자료구조]스택/스택삽입2.png)


따라서 `스택`의 `push`연산은 다음과 같다.
```
funtion push(data){
    데이터를 현재 스택의 꼭대기 위에 쌓음
    스택의 꼭대기 위치를 방금 전에 쌓은 위치로 갱신 
}
```

## Peek

스택의 가장 꼭대기에 있는 데이터를 가져오는 것이므로 top에 접하면 된다.
```
funtion peek(){
    스택의 꼭대기에 있는 데이터 반환;
}
```

## Pop

스택의 상태를 다음이라 가정하자.

![스택 삭제전](/assets/img/[자료구조]스택/스택삭제전.png)

Pop연산을 진행해보자.<br>
이 상태에서 제일위에 있는 데이터는 top에 위치한 9 이다. 따라서 이 데이터를 제거한다.

![스택 삭제](/assets/img/[자료구조]스택/스택top삭제.png)

그리고 스택의 꼭대기 위치인 top은 1 줄인다. 왜일까?
- 9 를 push 하기전엔 어떤 상태였을 지 생각해보자. 
- 9를 push 하면서 스택의 top이 4로 늘어난 것이다. 
- 그렇다면 top이 1 줄어들면 9를 push하기전의 꼭대기 위치가 된다.

![스택 top감소](/assets/img/[자료구조]스택/스택삭제top감소.png)

따라서 pop연산은 다음과 같다.

```
function pop(){
    스택의 꼭대기를 한 칸 낮춤
}
```

## IsEmpty
스택이 비었는지 어떻게 확인할 수 있을까? 스택에 1개의 데이터가 있다 가정하자.

![스택 원소 1개](/assets/img/[자료구조]스택/스택삽입2.png)

이제 여기서 pop연산을 수행하면 top은 -1 이 되며 스택엔 어떤 데이터도 없게 된다.

![빈 스택](/assets/img/[자료구조]스택/초기스택.png)

따라서 스택이 비어있는 조건은 top이 -1일 때이다. 이때는 pop연산을 통해 top을 줄여선 안된다. 비어있는 스택에 pop연산을 진행한 후, 새로운 데이터를 넣으면 top은 -1이 되기 때문이다.

```
funtion isEmpty(){
    스택의 꼭대기가 스택이 바닥인지를 반환
}

//pop 연산 수정!
funtion pop(){
    if isEmpty()==false: 
        스택의 꼭대기를 한 칸 낮춤
}
```
# 시간복잡도
- 위의 모든 연산은 스택의 크기와 무관하게 일정한 시간이 걸린다. 
- 따라서 4가지 연산 모두 $O(1)$ 의 시간복잡도를 가진다.

# 스택이 가득 찬다면?
만약 배열로 구현한다면 스택이 가득찬 지 확인하는 isFull 연산을 추가해야한다.
- 만약 스택내 배열의 길이가 _n_ 이라면 배열의 마지막 인덱스는 n-1이 된다. 
- 즉, top 이 `배열의 길이-1` 이면 스택이 가득찬 것이다. 
- 하지만 연결리스트를 활용하여 스택을 만들면 이론적으로 길이의 제한이 없어진다. 

실제 스택이 어떻게 작동하는지는 다음 