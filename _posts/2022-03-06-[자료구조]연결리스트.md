---
title: "[자료구조] 연결리스트"
author:
name: 이민석
date: 2022-03-09 14:00:00 +0900
categories: ["CS","자료구조"]
tag: ["자료구조"]
math: true
---
# 연결리스트
  연결리스트란 여러 `노드(Node)`를 연결하여 `순차적`으로 데이터를 저장하는 선형 자료구조이다. 
## 노드?
`노드`는 `하나의 데이터`와 다른 노드의 주소를 저장할 수 있는 `포인터`를 1개이상 가지고 있는 기본 단위이다.

![연결리스트](/assets/img/[자료구조]연결리스트/노드.png)
_데이터와 1개의 포인터를 가지고 있는 노드_

쉽게 생각하면 `데이터`를 `집`, `포인터`를 `다른 집`의 `주소`이다.

# 연결리스트의구조
`배열`처럼 `데이터`들을 `순차적`으로 저장하는 구조. 하지만 배열과 차이점이 있다.

- 메모리상에서 `데이터`들이 `순차적`으로 존재한다는 보장은 없다.

따라서  `포인터`를 통해 `노드`를 `순차적`으로 `연결`한다. 


 ![Desktop View](/assets/img/[자료구조]연결리스트/연결리스트.png)
_노드의 포인터는 다음 노드의 주소를 저장한다_

- 1개의 포인터를 가진 노드의 포인터가 다음노드를 가리키도록 연결리스트를 만들면 `단일 연결리스트` 라 부른다.
- 2개의 포인터를 가진 노드의 포인터들이 각각 다음노드, 이전 노드를 가리키도록 연결리스트는 `이중 연결리스트` 라 부른다.

![Desktop View](/assets/img/[자료구조]연결리스트/이중연결리스트.png)
_이중 연결리스트의 형태_

## Head
- `배열`에서 우리는 `첫 원소의 주소`을 안다면 임의의 원소의 주소에 접근할 수 있다. 
- `연결리스트`도 이와 비슷하다. `첫 노드`의 주소를 알고 있다면 임의의 노드에 접근할 수 있다. 
- 이 때 `첫 노드`를 `Head`라 부른다.

# 연산
- 연산의 편의성을 위해 `이중 연결리스트`를 사용한다고 가정한다.

## 특정 노드 접근
`k`번째 노드에 `접근`한다 해보다. 그렇다면 다음의 연산과정을 거친다.

>1. 노드 p=head를 둔다.
>2. p=(p의 다음 노드)를 k-1번 반복한다. 

- 2번과정에서, 최악의 경우는 `마지막 노드`에 접근하는 경우이다.  
- 이 과정에서 연산의 최대 횟수는 `연결리스트의 길이`에 정비례한다.

따라서 임의의 노드에 `접근`하는 연산은 $O(n)$의 시간 복잡도를 가진다. .

## 특정 데이터를 가진 노드 검색 
특정 데이터를 가진 노드를 찾기 위해선 다음의 과정을 거친다.

>1. 노드 p=head를 둔다.
>2. p의 데이터와 찾으려는 데이터를 비교한다.
>3. 다르다면 p를 p의 다음 노드로 둔다. 같다면 종료한다.

- 1,2번의 과정은 `연결리스트의 길이`와 상관없이 $O(1)$의 시간 복잡도를 가진다.
- 3번의 과정은 특정 노드에 `접근`하는 과정과 같다. 이는 $O(n)$ 의 시간 복잡도를 가진다.

따라서 데이터를 `검색`하는 연산은 $O(n)$ 의 시간 복잡도를 가진다.

> 배열과 달리 `정렬`된 연결리스트여도 $O(n)$의 시간 복잡도를 가진다.
{: .prompt-warning }

## 데이터 삽입
k번째 노드에 새로운 데이터를 삽입해보자. 이는 다음의 과정을 거친다.

>1. 새로운 데이터를 가지고 있는 노드 NewNode를 생성한다.
>2. k번째 노드를 찾는다.
>3. k-1번째 노드의 다음 노드를 가리키는 포인터에 NewNode의 주소를 저장한다.
>4. NewNode의 이전 노드를 가리키는 포인터에 k-1번째 노드의 주소를 저장한다.
>5. NewNode의 다음 노드를 가리키는 포인터에 k+1번째 노드의 주소를 저장한다.
>6. k+1번째 노드의 이전 노드를 가리키는 포인터에 NewNode의 주소를 저장한다.


- 1,3,4,5,6의 과정은 `연결리스트의 길이`와 상관없이 $O(1)$의 시간 복잡도를 가진다.
- 2번의 과정은 노드에 `접근`하는 연산이므로 $O(n)$의 시간 복잡도를 가진다.

따라서 임의의 위치에 데이터를 `삽입`하는 연산의 시간 복잡도는 $O(n)$ 이다..

>만약 k번째 노드의 주소를 알고 있다면 2번의 과정이 생략된다. 따라서 이 땐 $ O(1) $ 의 시간 복잡도를 가진다.
{: .prompt-tip }

## 데이터 삭제

k번째 노드의 데이터를 삭제해보자. 이 연산은 다음의 과정을 거친다.

>1. k번째 노드를 찾는다.
>2. k-1번째 노드의 다음 노드를 k+1번째 노드로 바꾼다.
>3. k+1번째 노드의 이전 노드를 k-1번째 노드로 바꾼다.

- 2,3번의 과정은 연결리스트의 길이와 상관없이 $O(1)$의 시간 복잡도를 가진다.
- 1번의 과정은 노드를 접근하는 연산이므로 $O(n)$의 시간 복잡도를 가진다.

따라서 데이터를 삭제하는 연산의 시간 복잡도는 $O(n)$ 이다.

>만약 k번째 노드의 주소를 알고 있다면 1번의 과정이 생략된다. 따라서 이 땐 $ O(1) $ 의 시간 복잡도를 가진다
{: .prompt-tip }

# 배열과의 비교
연결리스트와 배열은 서로 순차적으로 데이터를 저장한다는 특징을 가지고 있다. 그러면 각 연산에 대해서 배열과 연결리스트를 비교해보자.

| 연산   | 연결리스트| 배열 |
|:----------|:---------|-----:|
| 데이터 접근|$O(n)$    |$O(1)$|
| 데이터 검색|$O(n)$    |$O(n)$|
| 데이터 삽입|$O(n)$    |$O(n)$|
| 데이터 삭제|$O(n)$    |$O(n)$|

데이터의 접근을 제외하면 시간복잡도의 차이는 없짐나 정렬되어있는 배열은 데이터 검색이 $O(log n)$의 시간 복잡도를 가지게 된다. 그러면 연결리스트는 쓸 이유가 없을까? 
<H2> 당연히 아니다! </H2>

만약 저장하는 데이터의 크기가 (노드와 원소) 매우 크다고 해보자

배열의 경우, 데이터 복사가 많이 일어나기에 삽입과 삭제에 오랜 시간이 걸린다. 하지만 연결리스트는 각 노드들의 포인터만 바꾸면 되기에 배열에 비해서 많은 시간을 절약할 수 있다.
그리고 배열을 매우 길게 잡으면 사용하지 않는 공간만큼 메모리를 낭비하지만 연결리스트는 동적으로 길이가 조절된다.

이처럼 비슷한 구조를 가진 자료구조라도 각각의 차이점으로 장단점이 생긴다. 따라서 지금 환경이 어떤지를 고려하여 자료구조를 선택하는 것은 매우 중요한 과정이다.
