---
title: "[BOJ] xor 쿼리"
author:
name: "이민석"
date: 2023-12-03 20:28:00 +0900
categories: ["PS"]
tags: ["트라이"]
math: true
---


[BOJ xor 쿼리](https://www.acmicpc.net/problem/30865)

## 풀이
먼저 $\{a_n\}$ 의 비트에 대한 트라이를 만들어준다.($a_i$ 에 대하여 31번째 비트부터 순차적으로)

그리고 트라이에 숫자를 삽입할 때, 노드를 탐색하며 각 노드에는 자신을 거쳐간 수의 개수를 저장해둔다.

1번 쿼리($1\ i \ x)$에 대해선 기존 $a_i$ 를 트라이에서 제거하면서 각 노드에는 자신을 거쳐간 수를 감소시킨다. 그 뒤, $a_i$ 를 $x$ 로 바꾼 뒤, $x$ 를 트라이에 삽입한다.

2번 쿼리를 처리할 때, 만들어진 트라이에 대하여 $i=$현재 확인할 비트 (31번째 비트부터 시작), $now=$마지막으로 방문한 노드(시작은 $root$ 노드) 로 하자. $x \& (1\ll i) = 1 \ll k $ 일 때, $\{a_n\}$ 에서 30번째 비트가 0인 수가 $k$개 이상이라면 $a_i \oplus x$ 에서 30번째 비트가 1인 수가 $k$개 이상이고 나머지 수들은 30번째 비트가 0이 된다. \
따라서 구하고자 하는 수는 $\{a_n\}$ 에서 30번째 비트가 0인 수 중에 있음을 알 수 있다. \
만약 $k$개 미만이라면 $\{a_n\}$ 에서 30번째 비트가 1인 수 중에 있다는 것이다.\
즉, $now$ 와 현재 $i$ 에 대하여 다음 단계의 노드를 거쳐간 개수를 비교하며 노드를 탐색한다면 $k$번째로 큰 $a_i \oplus x$ 를 구할 수 있다.