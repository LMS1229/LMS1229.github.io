---
title: "[자료구조]큐"
author:
name: 이민석
date: 2022-03-20 21:49:00 +0900
categories: ["CS"]
tag: ["자료구조"]
math: true
---

# 큐란?
마트에서 장을 보고 계산할 때 어떤 모습이 떠오르는가? 여러 모습들이 떠오르겠지만 언제나 `먼저` 계산대에 도착한 사람이 `먼저` 계산하고 나가는 것이다. 그리고 구슬만한 크기의 구멍을 가진 통로에 구슬들을 넣으면 `먼저` 들어간 구슬이 `먼저` 나온다. `큐` 란 이와 같이 먼저 `들어온` 데이터가 `먼저` 나오는 `선형 자료구조`이다.

# 큐의 구조
큐의 특징이 무엇인가? `들어온 순서` 가 곧 `나오는 순서` 이다. 
- 따라서 가장 앞에 있는 데이터의 위치인 `front` 를 알고 있어야한다. 
- `선형 자료구조` 이므로 `front`를 알면 그 다음 차례의 데이터의 위치도 알 수 있다. 
- `데이터의 삽입 위치`는 큐에 마지막에 들어간 데이터 뒤이다. 따라서 우리는 이 위치도 알아야 한다. 이를 `rear`라 한다. 
- 이를 클래스 형태로 표현하면 다음과 같다.

```C++
class Queue{
    private:
        int front,rear;
        int q[100]; //데이터들을 저장할 장소
    public:
        //operation method
}
```

- 그리고 큐의 연산 5가지로 이는 스택과 유사하지만 조금 다른 점은 데이터를 꺼내는 위치와 `큐가 가득찼는가`이다. 
    - 삽입(`put`)
    - 데이터 조회(`get`)
    - 데이터 삭제(`pop`)
    - 큐가 비었는가?(`isEmpty`)
    - 큐가 가득찼는가?(`isFull`)
그리고 큐의 초기 상태는 다음과 같다.

![초기큐](/assets/img/[자료구조]큐/초기큐.png)

# 큐의 연산

## 삽입
- 위에서 말했든이 `rear` 는 `데이터가 삽입할 위치`이다. 따라서 먼저 `rear`에 데이터를 넣는다. 

![삽입 1단계](/assets/img/[자료구조]큐/삽입1단계.png)

- 그리고 다음에 삽입할 `데이터`의 위치는 `rear`의 바로 뒤이므로 `rear`를 다음에 저장위치로 바꾼다.

![삽입 2단계](/assets/img/[자료구조]큐/삽입2단계.png)

따라서 삽입 연산은 다음과 같다.
```
function put(){
    큐의 rear위치에 데이터를 넣고 rear를 원래의 rear위치의 뒤로 바꾼다.
}
```

## 데이터 조회
- 위 상태에서 `front` 위치에 저장된 데이터를 조회하면 된다. 

```
function get(){
    return (큐의 front위치에 있는 데이터)
}
```
>스택과 마찬가지로 데이터를 조회할 땐, 항상 데이터가 존재하는지(큐가 비어있는지), 확인해야한다.
{: .prompt-warning }

## 데이터의 삭제
- 큐에 있는 데이터 중, 가장 먼저 들어온 데이터는 `front`위치에 있기에 `front`를 `front` 의 바로 뒤로 바꾼다.


![삭제](/assets/img/[자료구조]큐/삭제.png)
```
function pop(){
    큐의 front 를 front의 뒤로 변경
}
```

## 큐가 비었는지 확인
큐가 비었다는 것은 어떤 상태인지 생각해보자. 큐의 front는 현재 큐에서 가장 먼저 들어온 데이터의 위치다. 그 위치에 데이터를 넣는다면 큐는 현재 비어있다는 것이다. 
- 따라서 큐의 `front`와 `rear`의 위치가 같다면 큐는 현재 비어있는 상태다. 

```
function isEmpty(){
    return (front와 rear의 위치가 같은가?)
}
```

## 큐가 가득찼는지 확인
예시와 같이 선형큐에서 `rear`가 배열의 끝 바로 뒤가 되면 큐에 더이상 삽입할 수 없다. 배열의 길이가 $n$이라면 배열의 인덱스는 $\[0,n-1 \]$ 이다. 따라서 `rear`가 배열의 길이가 된다면 큐는 가득찬 상태이다. 

```
function isFull(){
    return (rear가 배열의 끝의 뒤인가?)
}
```

# 문제점
위와 같은 형태의 큐를 우린 `선형 큐` 라고 부른다. 그러나 위의 연산을 보면 `삽입과 삭제`를 반복하다보면 `사용하지 않는 공간`이 생긴다. 이를 해결하려면 `원형 큐` 와 `연결 큐` 를 이용하면 된다. 

# 원형 큐

원형 큐는 선형 큐 와 같이 배열을 쓰지만 이 배열을 마치 원처럼 순회한다.
- 원처럼 순환한다면 `front` 를 배열의 인덱스라 한다면 다음과 같은 순서로 옮겨갈 것이다 \(배열의 길이는 $n$ 이라 하자.\)

$$0,1,2,3,4,5,\dots,n-1,0,1,2,3,4,\dots$$

- 이러한 순회는 front=(front+1)%n 연산을 계속 반복하면 된다.
- 이는 rear에도 똑같이 적용된다. 

따라서 put과 get의 연산은 다음과 같이 변경된다. 
```
function put(){
    rear=(rear+1)%n
    store in q[rear]
}
function get(){
    front=(front+1)%n
}
```

그러나 이렇게만 끝내면 다음의 문제가 발생한다.

## 그래서 큐가 비었나요? 아니면 가득찼나요?
큐가 비어 있을땐 당연히 front\==rear이다. 하지만 길이가 n인 배열을 이용한 원형 큐에 n개의 데이터를 넣어도 front\==rear이다. 그러면 큐는 비어있기도 하고 가득차기도 한 상태인가??
- 이를 해결하기 위해 우리는 원형 큐에서 `rear`를 갱신하면 `front`와 같아질 때를 큐가 가득찼다고 한다.

```
function isFull(){
    return front==(rear+1)%n
}
```

# 연결 큐
연결 리스트를 응용해 만든 큐이다. 큐에는 데이터들이 각각 하나의 노드에 들어간 상태로 들어가있다. 

![연결큐예시](/assets/img/[자료구조]큐/연결큐.png)
_연결 큐의 한 예시이다_

위에 있던 배열을 이용한 큐와 다른 점은 `rear` 가 다음에 삽입할 위치가 아닌 마지막에 삽입한 위치라는 것이다. 따라서 연결 큐는 다른 형태의 연산 과정이 적용된다.

## 큐가 비었는지 확인
`front` 는 가장 먼저 들어온 노드이기 때문에 `front`가 가리키는 것이 null pointer라면 큐는 비어있는 상태이다.

```
function isEmpty(){
    return (front==null pointer)
}
```

## 큐가 가득찼는지 확인
이론적으로 연결 큐는 가득찬 상태가 없다. 왜냐면 길이가 정해진 선형 구조가 아니기 때문이다.

## 삽입
`rear`는 마지막에 삽입한 위치이다. 따라서 이 다음에 새로운 데이터를 가진 노드를 연결하고 그 노드를 `rear`로 두면 된다.

```
function put(){
    Node* newRear=new Node(data);
    rear->next=newRear;
    rear=newRear;
}
```
## 삭제
`front`가 가장 먼저 들어온 데이터의 위치이므로 `front`를 `front`의 `next`로 바꾸면 된다.
```
function pop(){
    front=front->next;
}
```
# 시간 복잡도

위의 모든 연산은 큐의 길이와는 무관하게 일정한 시간이 걸린다. 따라서 시간 복잡도는 모두 $O(1)$ 이다. 
