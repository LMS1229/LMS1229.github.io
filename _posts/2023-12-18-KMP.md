---
title: KMP
layout: post
author:
name: 이민석
date: 2023-12-18 22:00:00 +0900
categories: ["CS","알고리즘"]
tag : ["문자열"]
math: true
---

## 개요
어떤 문자열 $S$ 에 대하여 문자열 $T$ 가 부분 문자열인지 판별하기 위해선 어떻게 해야 할까? 
가장 쉬운 방법으로 $S$ 와 $T$ 의 길이를 $N ,\ M$ 라 한다면 모든 $i(0 \le i \le N-M)$ 에 대하여 $S[i:i+M-1] = T$ 인지 확인해보면 된다.\
이 방법의 시간 복잡도는 $O(NM)$ 을 가진다. 그러나 지금 소개할 알고리즘을 이용하면 $O(N+M)$ 의 시간 복잡도내에 해결할 수 있게 된다.   

---

## 문제점
두 문자열 $S,T$ 를 $S=ababababbb,\ T=ababb$ 라고 하자.\
이 때, $i=0$ 일 때를 비교하면 $S[4]\neq T[4]$ 이므로 다음 비교를 해야 한다.\
그리고 $i=1$ 인 경우엔 비교하지 않아도 되고 $i=2$ 인 경우를 비교해야 한다.\
즉 $S[i:i+M-1] = T$ 를 검사할 때, $S[x] \neq T[y]$ 라면 구간 $\[i+1,k\] \(k \le x\)$ 에 대해서 검사를 하지 않아도 된다. 그렇다면 $k$ 를 어떻게 구할까?\
이는 접두사와 접미사를 통해 구할 수 있다. 

---

### 접두사와 접미사
길이가 $N$ 인 문자열 $S$ 의 접두사는 $S[0:i] (0 \le i \le N-1)$ 인 문자열들을 일컫는다.\
예시로 $S=abcab$ 라면 $S$ 의 접두사인 문자열 집합 $S_{prefix}=\{S[0:i] | (0 \le i \lt N)\}=\{a,\ ab,\ abc,\ abca,\ abcab \}$ 가 된다.\
이와 반대로 접미사는 $S[i:N-1] (0 \le i \le N-1)$ 인 문자열들을 일컫고 이들의 집합
$S_{suffix} = \{abcab,\ bcab,\ cab,\ ab,\ b \}$ 로 표현할 수 있다.

---
## 알고리즘
길이가 $N,\ M$인 문자열 $S,T$에 대하여 현재 $S[i],T[j]$ 를 비교한다고 가정하자.
이 때 $S[i] \neq T[j]$ 이면 $T[0:j-1]$의 접두사와 접미사를 비교해 같은 것을 찾아보자. ($T[0:j-1]$ 은 제외)

만약 이것이 존재하지 않는다면 $S[i]=T[0]$ 와 비교를 하면 된다.

만약 존재한다면 이런 문자열 중 가장 길이가 긴 문자열을 $T_{suffix=prefix}(j-1)$ 이라 하자.\
그렇다면 $T_{suffix=prefix}$ 길이를 $f(j-1)$ 라 한다면 $T[j-f(j-1):j-1] = T[0:f(j-1)-1] = S[i-j:i-j+f(j-1)-1] = S[i-f(j-1):i-1]$ 가 성립한다.

따라서 $j \leftarrow f(j-1)$ 로 바꾸어도 $T[0:f(j-1)-1]=S[i-f(j-1):i-1]$ 가 성립하므로 $T[f(j-1)]$ 와 $S[i]$ 를 비교해도 무방하다.\
이 때, 모든 $i-j \lt x \lt i-f(j-1)$ 에 대하여 $S[x:x+M-1] \neq T$ 이므로 ($\because S[i] \neq T[j]$) 불필요한 비교를 모두 건너뛰게 된다.

만약 $S[i]=T[j]$ 라면 $i \leftarrow i+1,\ j \leftarrow j+1$ 로 바꾸어 위 과정을 진행하면 된다. 

이를 의사 코드로 표현하면 다음과 같다.

```
S ← 탐색할 문자열
T ← 확인할 부분 문자열
P ← Array (P[x] → S[P[x]-length(T)+1:P[x]] = T)
j ← 0
for i ← 0 to length(S)-1:
    while (j > 0 and T[j] != S[i]):
        j ← f(j-1)
    if T[j] = S[i] 
        then 
            j ← j + 1
    if j = length(T)
        then
            P.push(i)
            j=f(j-1)

return P
```
이 때, P의 크기가 0보다 크다면 $S$ 안에 $T$ 가 존재함을 의미한다.

따라서 우리는 $f(j-1)$ 를 빠르게 구할 수만 있다면 위 문제가 해결된다.\
이 때, $f(x)$의 값들은 $x$ 에 대한 테이블로 정의할 수 있으며 이를 실패 함수라고 부른다. 

---

## 실패 함수
이런 실패 함수의 값은 위와 비슷하게 구할 수 있다.\
$T[0:j]$ 에 대하여 $f(j)$ 값을 구한다 가정하자. $f$ 의 정의에 따라 $T[0:f(j-1)-1]=T[j-f(j-1):j-1]$ 이다. \
따라서 $T[f(j-1)]=T[j]$ 라면 $f(j) = f(j-1)+1$ 이다.

만약 $T[f(j-1)] \neq T[j]$ 라면 $t=f(j-1)$ 라고 했을 때, $f$ 의 정의에 의해 $T[0:f(t)-1] = T[j-f(t):j-1]$ 가 되며 $j-f(j-1) \lt x \lt j-f(t)$ 에 대하여 $T[x:j-1] \neq T[0:j-x-1]$ 이다. 

따라서 $T[t=f(f(..f(j-1)))]=T[j]$ 를 만족하는 $t$ 를 찾으면 된다. 

자세한 방법은 다음과 같다.

```
T ← 확인할 부분 문자열
j ← 0
pi ← Array (length(pi) = length(T)) 
pi[0] ← 0
for i ← 1 to length(T)-1:
    while (j > 0 and T[j] != T[i]):
        j ← pi[j-1]
    if T[j] = T[i] 
        then 
            j ← j + 1
    pi[i] ← j
return pi
```

---

## 시간 복잡도 
먼저 실패 함수를 만드는 과정을 분석해보자.\
현재 $j$ 에 대하여 `while` 문의 수행횟수 $x$는  $O(j)$ 이다. 

그 이유는 $j$ 에 대하여 $T[i-k] \neq T[j-k]$ 인 $k$ 는 최대 $j$개 이기 때문이다.\
따라서 `while` 문의 총 수행횟수는 `j ← j + 1` 의 연산 횟수에 비례하며 이는 $O(M)$ 의 시간 복잡도를 가진다. \
또한 바깥 루프문도 시간 복잡도가 $O(M)$ 이므로 총 수행 시간은 $O(M)$ 이 된다.

$S$ 에서 $T$ 를 찾는 경우, 또한 `j ← j + 1` 의 연산 횟수는 $O(N)$ 이다. 그러나 여기선  
`if j = length(T)` 구문을 분석할 필요가 있다.

결론적으로 말하면 이로 인해 추가되는 `while` 문의 총 수행 횟수 $O(N)$ 이다. \
그 이유는 다음과 같다.\
`if j = length(T)` 인 경우, `while` 문의 총 수행 횟수는 $O(f(j-1))$ 만큼 늘어나게 된다.\
하지만 이 횟수는 결국 `j ← j + 1` 의 연산 횟수와 같게 된다. (예시로 $x$ 번 만큼 늘어나고 이로 인해 $y$번 감소하여도 $i$ 가 최소 $y$ 만큼 증가, 즉 `j ← j + 1` 연산을 최소 $y$ 만큼 해야 한다는 것)

즉, $T$를 찾는 과정도 $O(N+M)$ 의 시간 복잡도를 가진다.